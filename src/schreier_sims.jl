"""
    PointStabilizer{P<:AbstractPermutation}
A structure to represent (partial) stabilizer chain.

If `G` is a group generated by a set of permutations, then for a choice of basis
> `β = (β₀, β₁, …, βₙ)`

we obtain a sequence of groups
> `G = G₀ ≥ G₁ ≥ … ≥ G₀ = {1}`.

where `Gₖ₊₁ ≤ Stab_{Gₖ}(βₖ)`. A `pts::PointStabilizer` typically represent `Gₖ`
in the following sense:
 * `gens(pts)` is the generating set for `Gₖ`,
 * `point(pts)` returns `βₖ`
 * `transversal(pts)` is the transversal of `βₖ` w.r.t. to `gens(pts)` and
 * `stabilizer(pts)::PointStabilizer` represents `Gₖ₊₁`.

`pts` represents `G₀` (i.e. the trivial group) if `istrivial(pts) == true`.
"""
mutable struct PointStabilizer{P<:AbstractPermutation}
    S::Vector{P}
    T::Transversal{Int,P}
    stab::PointStabilizer{P}

    PointStabilizer{P}() where {P} = new{P}(P[])
end

gens(pts::PointStabilizer) = pts.S
stabilizer(pts::PointStabilizer) = pts.stab
transversal(pts::PointStabilizer) = pts.T

point(pts::PointStabilizer) = first(transversal(pts))
istrivial(pts::PointStabilizer) = isempty(gens(pts))

# schreier_sims implementation
function schreier_sims(S::AbstractVector{P}) where P<:AbstractPermutation
    sc = PointStabilizer{P}()
    for s in S
        push!(sc, s)
        end
    return sc
end

function Base.push!(pts::PointStabilizer, g::AbstractPermutation)
    g = sift(pts, g)
    isone(g) && return pts

    if istrivial(pts)
        extend_chain!(pts, g)
    else
        extend_gens!(pts, g)
    end
end

function sift(pts::PointStabilizer, g::AbstractPermutation)
    if istrivial(pts) || isone(g)
        return g
    else
        T = transversal(pts)
        x = point(pts)
        δ = x^g
        if δ ∉ T
            return g
        else
            r = T[δ]
            g = g*inv(r)
            @assert x^g == x
            return isone(g) ? g : sift(stabilizer(pts), g)
        end
    end
end

function extend_chain!(pts::PointStabilizer{P}, g::AbstractPermutation) where {P}
    @assert !isone(g)

    # we want to modify pts in-place, so we access the fields directly
    push!(pts.S, g)
    # the special transversal constructor with a single generator
    pts.T = Transversal(first_moved(g), g, ^)
    pts.stab = PointStabilizer{P}() # the next stabilizer is empty

    k = length(transversal(pts))
    if k < order(g)
        # gᵏ stabilizes point(pts) so is a generator for stabilizer(pts)
        extend_chain!(pts, g^k)
    end
    return pts
end

function extend_gens!(pts::PointStabilizer, g::AbstractPermutation)
    @assert !isone(g)

    # a very simple version
    push!(pts.S, g)
    pts.T = Transversal(point(pts), gens(pts), ^)

    tr = transversal(pts)
    for s in gens(pts)
        for δ in tr # iterating over orbit
            schr = tr[δ] * s * inv(tr[δ^s]) # a new Schreier generator
            isone(schr) && continue
            @assert point(pts)^schr == point(pts)
            push!(stabilizer(pts), schr)
        end
    end
    return pts
end
