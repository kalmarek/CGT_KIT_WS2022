# Computational Group Theory WS2022 - Projects

 ## A. Permutation Groups

1. Solving the Rubik cube
   * Represent the Rubik cube group as generated by moves rotating (T)op, (B)ottom, (L)eft, (R)ight, (F)ront and bac(K) faces
   * given a random element of the Rubik cube group decompose it into a product of the generators
   * _for an advanced option read_: https://doi.org/10.1006/jsco.1998.0202
2. Transversals: comparing different implementations for speed and size
   * Implement three different versions of Transversals
   * Test their speed on the same `schreier_sims` algorithm and a variety of inputs including: `Sym(n)`, `Matthieu` groups, `Janko` groups, `Suzuki` groups, etc.
   * Write a short report (1-3 pages) of your findings
3. Comparing versions of Product Replacement Algorithm (_PRA_)
   * There are a few different version of _PRA_:
     * vanilla (https://doi.org/10.1080/00927879508825509)
     * with accumulator, (http://dx.doi.org/10.1090/conm/298)
     * prospector (https://doi.org/10.1016/j.jsc.2011.08.017)
   * implement them and compare for a variety of input groups and generating sets (different pre-mixing time, different sizes of the generating $n$-tuple)
   * Write a short report (1-3 pages) of your findings
4. Conjugacy testing via backtracking
   * implement a usable backtrack search (as an iterator) on the stabilizer chain of a permutation group, which minimizes the number of group multiplications
   * implement specific heuristics for conjugacy testing within permutation groups
   * _advanced_: parallelize the tree exploration by assigning separate threads to disjoint branches (use `Channels` for communicating the results to the main thread)
5. Improvements to the Schreier-Sims algorithm
   * using `Word`s in generators to represent products
   * incorporate the knowledge of the order of group into the algorithm to break quickly
   * probabilistic Monte-Carlo version with probabilistic verification of the results

## B. Finitely Presented Groups

1. Enhanced version of the Knuth-Bendix algorithm
   * Implement version with stack which maintains reducedness
   * use index automaton for rewrites
   * add tunable delayed reduction of stack
   * produce the reduced and confluent rewriting system for $\operatorname{Grp}\langle a,b\mid 1 = a^2 = b^3=(ab)^7 = (abab^2)^n\rangle$ for $n=1,…,8$
   * explore different strategies by examining e.g. short/long overlaps first
2. Finiteness testing based on index automaton
   * Implement the enumeration of words irreducible w.r.t. an index automaton $\mathcal{A}$
   * Solve exercise 6.3 from [Sims, C., _Computation with finitely presented groups_, Chapter 3, p. 126]
   * Implement the method described there to determine if the language of $\mathcal{A}^c$ (the complement, i.e. automaton recognizing $X^* - \mathcal{L}(\mathcal{A})$) is infinite.
3. Tietze transformations.
   * Implement Tietze transformations
   * Write a simple algorithm to simplify group presentations using those
   * Explore different strategies such as [here](https://staff.itee.uq.edu.au/havas/1984hkrr.pdf) and [here](https://doi.org/10.1016/S0747-7171(88)80021-X) (great examples in both of the papers).
   * Read through [GAP Documentation](https://docs.gap-system.org/doc/ref/chap48_mj.html#X782985197BE809BF) on the topic and try to replicate some of the examples of simplifying presentation.
4. Suffix automaton
   * Suffix automaton is a minimal (smallest) deterministic automaton that accepts all the suffixes of the word  $w \in X^*$.
   * Implement a construction of suffix automaton and use it to find if prefix of another word $v$ is a suffix of $w$ (in time linear with $|v|$)
   * Use this procedure in `resolve_overlaps!`
5. Automata based on matrix transition tables
   * Implement index automaton based on matrix storage of transition table (instead of node-based structure as in the lecture).
   * Compare creation time, and performance for rewriting  backtracking (i.e. `isconfluent`) of those structures.
   * Write a short report (1-3 pages) of your findings.
6. Operations on automata
   * Let $\mathcal{A}$ be a finite automaton over $X$ with language $\mathcal{L}$.
   * Implement common operations on automata that are needed for checking if the language of $\mathcal{A^c}$, i.e., $X^* - \mathcal{L}$ is infinite (complement, accessible subset, completion, loop finding, ...)
   * _advanced_: Let $M = \operatorname{Mon}\langle X \mid \mathcal{R} \rangle$ be a monoid defined by a rewriting system $\mathcal{R}$. If $N$ is a finite quotient of $M$, i.e. $N = \operatorname{Mon}\langle X\mid \mathcal{R}\sqcup \mathcal{S} \rangle$ we can sometimes determine its size, even when $\mathcal{R}\sqcup \mathcal{S}$ is not confluent, by running Knuth-Bendix words w.r.t. $M' = \langle X\sqcup\{\#\} | \mathcal{R}\sqcup \{\#P \rightarrow \#Q \colon P\rightarrow Q \in \mathcal{S}\}$. Implement this check following _Example 10.2_ in [Sims, C., _Computation with finitely presented groups_, Section 3.10].
7. Solving the word problem using small cancellation
   * M. Dehn in 1910 proved that the fundamental groups of surfaces have solvable word problem by providing an explicit algorithm (known now as the _Dehn algorithm_).
   * Learn about the algorithm and implement it in an efficient manner to run it in any $C'(\lambda)$-small cancellation group (Note: for $\lambda ≥ 1/6$ it provides a solution to the word problem).
8. Whitehead algorithm for primitivity of elements in the free group $F_n = \operatorname{FreeGrp}\langle X \rangle$, $X = \{x_1, \ldots, x_n\}$.
   * $w$ (a freely reduced word over $X$) is said to be primitive if $[w]\in F_n$ can be chosen to be a generator of some (group) generating set of size $n$, or equivalently if there exist an automorphism $f\in \operatorname{Aut}(F_n)$ such that $f([x_1]) = [w]$.
   * R.C. Lyndon and P.E. Schupp in Chapter I.4 of _Combinatorial Group Theory_ (see Proposition 4.19) give a description of an algorithm which decides if $w$ is primitive. Learn more about the complexity of the algorithm and implement it in any form (see e.g. [various heuristics](https://doi.org/10.1080/10586458.2005.10128906), [a stochastic search](https://doi.org/10.1016/j.jsc.2006.04.001) and a non-explicit [proof of polynomial time](https://arxiv.org/abs/math/0608779)).
   * _advanced_: Implement the algorithm for a tuple of words $(w_1, \ldots, w_n)$ which will determine an automorphism $f\in \operatorname{Aut}(F_n)$ such that $f(x_i) = w_1$ if such $f$ exists.

## Project Selection
Project selection is located [here](https://forms.gle/UJ3yYfU2nS4q2Ner5).
