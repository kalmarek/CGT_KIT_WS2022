### A Pluto.jl notebook ###
# v0.19.14

using Markdown
using InteractiveUtils

# ╔═╡ f36e0390-c44a-4901-83b5-d8180fcdaba6
abstract type GroupElement end

# ╔═╡ 4118ac8d-3e55-4717-ac1f-98a3446b5eff
md"
>**Exercise 1**:
>1. Create `struct CyclePermutation <: AbstractPermutation` that stores `cycles::Vector{Vector{Int}}` in its fields.
>2. Implement the `AbstractPermutation` interface i.e. `degree` and obtaining the image of `i::Integer` under such permutation.
>3. Verify the correctness of multiplication, inversion etc. by writing appropriate `begin ... end`  block with `@assert`s.
>4. What happens if we multiply `CyclePermutation` and `Permutation` together? Can you find where does this behaviour come from?

>**Exercise 2**: (_Advanced_)
>1. Write a function that takes a string representing a permutation in its cycle form, e.g. `\"(2,3,1)(4,5)\"` and returns an instance of `AbstractPermutation`.
>2. Find about string macros in julia documentation and turn such function into a **string macro** so that writing `perm\"(2,3,1)(4,5)\"` produces `Permutation([2,3,1,5,4])`.
"

# ╔═╡ e5f0e567-5d28-424e-83d0-4ca82e967865
md"
# Orbits
"

# ╔═╡ 6007ee88-debe-4dc6-8bec-d730c38e0aec
begin
"""
    orbit_plain(x, S[, action=^])
Compute the orbit of `x` under the action of a group `G` generated by set `S`.

It is assumed that elements `g ∈ G` act on `x` _on the right_ via `action(x, g)`.

### Input
 * `x` - point in a set `Ω`
 * `S` - finite generating set for `G = ⟨S⟩`.
 * `action` - action of `G` on `Ω` from the right, defaulting to `^`.
### Output
 * `{xᵍ | g ∈ G}` - the orbit of `x` under the action of `G`, returned as a `Vector`.
"""
orbit_plain(x, S::AbstractVector{<:GroupElement}, action=^) = orbit_plain!([x], S, action)

function orbit_plain!(x::AbstractVector, S::AbstractVector{<:GroupElement}, action=^)
    @assert !isempty(S) # groups need generators
    Δ_vec = x
    Δ = Set(Δ_vec)
    for δ in Δ_vec
        for s in S
            γ = action(δ, s)
            if γ ∉ Δ
                push!(Δ, γ)
                push!(Δ_vec, γ)
            end
        end
    end
    return Δ_vec
end
end

# ╔═╡ 13abc38b-a0a2-46ac-a58a-24fead1f6702
begin
# taken from `src/AbstractPermutations.jl`
"""
    AbstractPermutation
Abstract type representing permutations of set `1:n`.

Subtypes `Perm <: AbstractPermutation` must implement the following functions:
* `Base.:^(i::Integer, σ::Perm)` - the image of `i` under `σ`,
* `degree(σ::Perm)` - the minimal `n` such that `k^σ == k` for all `k > n`,
* `Perm(images::AbstractVector{<:Integer}[, check::Bool=true])` - construct a
`Perm` from a vector of images. Optionally the second argument `check` may be
set to `false` when the caller knows that `images` constitute a honest
permutation.
"""
abstract type AbstractPermutation <: GroupElement end

"""
    degree(σ::AbstractPermutation)
Return a minimal number `n` such that `σ(k) == k` for all `k > n`.

Such number `n` can be understood as a _degree_ of a permutation, since we can
regard `σ` as an element of `Sym(n)` (and not of `Sym(n-1)`).

By convention `degree` of the trivial permutation must return `1`.
"""
function degree end

Base.one(σ::P) where P<:AbstractPermutation = P(Int[], false)
Base.isone(σ::AbstractPermutation) = degree(σ) == 1

function Base.inv(σ::P) where P<:AbstractPermutation
    img = similar(1:degree(σ))
    for i in 1:degree(σ)
        img[i^σ] = i
    end
    return P(img, false)
end

function Base.:(*)(σ::P, τ::AbstractPermutation) where P<:AbstractPermutation
    deg = max(degree(σ), degree(τ))
    img = similar(1:deg)
    for i in 1:deg
        img[i] = (i^σ)^τ
    end
    return P(img, false)
end

function Base.:(==)(σ::AbstractPermutation, τ::AbstractPermutation)
    degree(σ) ≠ degree(τ) && return false
    for i in 1:degree(σ)
        if i^σ != i^τ
            return false
        end
    end
    return true
end

function Base.hash(σ::AbstractPermutation, h::UInt)
    h = hash(AbstractPermutation, h)
    for i in 1:degree(σ)
        h = hash(i^σ, h)
    end
    return h
end

function Base.show(io::IO, σ::AbstractPermutation)
    if isone(σ)
        print(io, "()")
    else
        for cycle in cycle_decomposition(σ)
            if length(cycle) == 1
                continue
            else
                is_trivial = false
                print(io, "(")
                join(io, cycle, ",")
                print(io, ")")
            end
        end
    end
end

function cycle_decomposition(σ::AbstractPermutation)
    visited = falses(degree(σ))
    cycles = Vector{Vector{Int}}()
    # each cycle will be a Vector{Int} and we have a whole bunch of them
    for i in 1:degree(σ)
        if visited[i]
            # if we have already seen this point there is no point in computing
            # the same orbit twice
            continue # i.e. skip the rest of the body and continue with the next i
        end
        Δ = orbit_plain(i, σ, ^)
        visited[Δ] .= true # modify the `visited` along the whole orbit
        push!(cycles, Δ) # add obtained orbit to cycles
    end
    return cycles
end

function orbit_plain(x, s::GroupElement, action=^)
    Δ = [x]
    γ = action(x, s)
    while γ != x
        push!(Δ, γ)
        γ = action(γ, s)
    end
    return Δ
end

AbstractPermutation
end

# ╔═╡ 423e67fc-a756-4ba7-8e4d-fabfb7e22045
begin
	struct Permutation <: AbstractPermutation
		images::Vector{Int}
	
		function Permutation(v::Vector{<:Integer}, check=true)
			if check
				@assert sort(v) == 1:length(v) "Image vector doesn't define a permutation"
			end
			return new(v)
		end
	end
	
	# ## Interface of AbstractPermutation
	Base.:^(n::Integer, σ::Permutation) = 
		(n > length(σ.images) ? convert(Int, n) : σ.images[n])
	
	function degree(σ::Permutation)
		for i in length(σ.images):-1:1
			if i^σ ≠ i
				return i
			end
		end
		return 1
		# return something(findlast(i->σ.images[i]!=i, 1:length(σ.images)), 1)
	end
end

# ╔═╡ 261f2777-c2cc-498e-a7ef-a819f779344c
σ = Permutation([2,1,3])

# ╔═╡ 9b3ef828-f64c-42b5-a7d8-ed7d2e0f96a9
τ = Permutation([1,3,2])

# ╔═╡ 57982949-1cb9-4077-afd7-444fb42f0fec
methods(degree)

# ╔═╡ 18121dc3-78d2-4334-b1bb-9b3cba02d730
σ*τ

# ╔═╡ f803b4d4-f93f-432f-950f-8699602f4d92
@assert perm"(1,2)" == σ

# ╔═╡ cadb4c9c-2548-49ef-bf5b-4e018f886d9a
orbit_plain(1, Permutation([2,3,4,1]))

# ╔═╡ acf34ce7-45af-4de0-81c0-fa50948584ee
md"
### Generating all permutations in a group
Suppose that we're given a set of permutations `S`. What is the group generated by `S`? How can generate __all elements__ in `G = ⟨S⟩`? 

Previously we were acting via `^` on single numbers like, e.g. `orbit_plain([σ, τ], 1, ^)` produces internally
```julia
	1^σ
	1^τ
	(1^σ)^σ
	(1^σ)^τ
	...
```
to obtain all elements in the orbit of `1`.

So if we replace `1` by `e` (the group identity) and `^` by `*`, the call `orbit_plain([σ, τ], e, *)` will compute
```julia
	e*σ
	e*τ
	(e*σ)*σ
	(e*σ)*τ
	...
```
creating all possible finite products of `σ` and `τ` i.e. obtaining the whole group generated by `S = [σ, τ]`.
"

# ╔═╡ 9838d4b1-da7a-4b6a-8e18-a32ac465805c
let σ = Permutation([2,3,4,1]), τ = Permutation([2,1])
	S = [σ, τ]
	@info S
	e = one(σ)
	Δ = orbit_plain(e, S, *)
	@assert length(Δ) == 24
	Δ
end

# ╔═╡ 19367a34-9d88-4dbb-baed-4cea5b0a5eac
md"
# Transversals

Let `G = ⟨S⟩` and `x ∈ Ω` be a point, where `G` acts on `Ω` as usual (through `^`)
and let `Δ` be the orbit of `x`, i.e.

$$\Delta = (x, x^{g}, x^{h}, x^{gh}, \ldots )$$
(considered as __ordered set__).

**Definition**: A **transversal** is either
* the set of representatives of the coset set
$$
\operatorname{Stab_G}(x)\setminus G =\{
\operatorname{Stab_G}(x)e, \operatorname{Stab_G}(x)g, \operatorname{Stab_G}(x)h, \operatorname{Stab_G}(x)gh, \ldots \},$$
* the set `T` of group elements which takes `x` to consecutive elements (considered as __ordered set__) in $x^G$:
$$(e, g, h, gh,\ldots)$$.

> **Exercise 3**: Modify `orbit_plain` algorithm to compute the transversal as well. When given a point `y` in the orbit tansversal `T` should be able to determine `g ∈ G` which takes `x` to `y`. Recall that we denote this by saying that `T[y] = g`.
>
>_Tip_: For transversals use julias `Dict` dictionary (hashmap) structure. 
"

# ╔═╡ f52cb4dd-03d8-4526-880c-4aaad81412ab
"""
    transversal(x, S::AbstractVector{<:GroupElement}[, action=^])
Compute the orbit `Δ` and a transversal `T` of `x ∈ Ω` under the action of `G = ⟨S⟩`.

Transversal is a set of representatives of left cosets `Stab_G(x)\\G` satisfying

    x^T[γ] = γ

for every `γ ∈ Δ`.

It is assumed that elements `G` act on `Ω` _on the right_ via `action(x, g)`.

### Input
 * `x` - point in set `Ω`,
 * `S` - finite generating set for `G = ⟨S⟩`,
 * `action` - function defining an action of `G` on `Ω` from the right. Defaults to `^`.
### Output
 * `Δ::Vector` - the orbit of `x` under the action of `G`.
 * `T::Dict` - a transversal.
"""
function transversal(x, S::AbstractVector{<:GroupElement}, action=^)
    @assert !isempty(S)
    
	return Δ, T
end

# ╔═╡ 2fa081db-4ae0-4af6-b513-65d32c3ff856
let σ = Permutation([1,3,4,2]), τ = Permutation([1,2,4,5,3]), x = 2
	Δ, T = transversal(x, [σ, τ])
	for δ in Δ
		@assert 2^T[δ] == δ
	end
	Δ, T
end

# ╔═╡ 8acfbaf5-498a-473c-b03a-5eab478ac3b3
md"
## Schreier Vectors aka factored transversals
Suppose that `S = [s₁, …, sₖ]`. The aim now is, instead of storing actual generators in the transversal, to store only generator _indicies_, i.e. instead of
```julia
[e, s₂, s₁, s₂]
```
store only
```julia
[2, 1, 2]
```
The former requires  

	n*degree(s)*sizeof(Int) = n*d*8

bytes (where `n` is the ~length of the orbit) whereas the latter needs only

    n*sizeof(Int) = n*8

bytes, which is **independent** on the degree of the permutations!
The price we pay is that we store the elements in _factored_ form, so whenever asked for a coset representative we need to perform ~`n` multiplications to recover it.

Of course we also need to keep `S` around.
"

# ╔═╡ d20d14a4-3414-453d-943f-c760465d0ba7
md"
### Factored transversal
Let us try to store factorisation of representatives in the transversal.
Thus this time we start by saying that
```julia
T = Dict(x => [one(first(S))])
```
will hold lists of elements (starting with the identity) and that 
```julia
T[γ] = [T[δ]; s]
```
the next point in the transversal points to the factored representation of the previous the the new generator `s` added at the end.
"

# ╔═╡ 23122d5c-8545-43b9-a33a-2da78a46538a
function transversal_factored(x, S::AbstractVector{<:GroupElement}, action=^)
    @assert !isempty(S)

    return Δ, T
end

# ╔═╡ cc0fa689-6d78-4489-9faf-c4ef1b5dc762
let σ = Permutation([1,3,4,2]), τ = Permutation([1,2,4,5,3]), x = 2
	Δ, T = transversal_factored(x, [σ, τ])
	@assert length(Δ) == 4
	for δ in Δ
		@assert x^prod(T[δ]) == δ
	end
	Δ, T
end

# ╔═╡ c73c88f0-a7ec-4260-af2a-665d1fadc150
let σ = Permutation([1,4,2,3]), τ = Permutation([2,3,1]), x = one(σ)
	S = [σ, τ]
	e = one(σ)
	Δ, T = transversal_factored(e, S, *)
	@assert length(Δ) == 12
	for g in Δ
		@assert g == prod(T[g])
	end
end

# ╔═╡ 8951b592-0554-45c5-81b8-f1eac7d372dd
"""
    schreier(x, S::AbstractVector{<:GroupElement}[, action=^])
Compute the orbit and a Schreier tree of `x ∈ Ω` under the action of `G = ⟨S⟩`.

It is assumed that elements `G` act on `Ω` _on the right_ via `action(x, g)`.

### Input
 * `x` - point in set `Ω`,
 * `S` - finite generating set for `G = ⟨S⟩`,
 * `action` - function defining an action of `G on `Ω` from the right. Defaults to `^`.
### Output
 * `Δ::Vector` - the orbit of `x` under the action of `G`, as a `Vector`.
 * `Sch::Dict` - a Schreier tree, satisfying `S[Sch[γˢ]] == s` for every `γ ∈ Δ` and every `s ∈ S`.
"""
function schreier(x, S::AbstractVector{<:GroupElement}, action=^)
    @assert !isempty(S)

    return Δ, Sch
end

# ╔═╡ b6669b69-53f2-4ef5-a17d-b45a9403a523
let σ = Permutation([2,1,4,3]), τ = Permutation([1,3,4,2]), x = 2
	S = [σ, τ]
	@info "" S
	Δ, Sch = schreier(x, S)
	for (idx,δ) in pairs(Δ)
		δ == x && continue
		k = δ^inv(S[Sch[δ]])
		@assert findfirst(==(k), Δ) < idx
	end
	S, Δ, Sch
end

# ╔═╡ c4c22682-4bbb-4d6d-a9a5-11afe67f200d
md"
Now, given such _Schreier Vector_ (but is it really a vector?) let's reconstruct a coset representative. I.e. given
 * `Δ` the orbit of `x` under `⟨S⟩`
 * `T` the factored transversal (=_Schreier Vector_)
 * `y ∈ Δ`
how to reconstruct the coset representative corresponding to `y`?

The answer is to walk the factored transversal __backward__`. Here's this in _pseudo-code_:
```julia
let current_point = y
	coset_rep = e
	while current_point ≠ x
		s = ... # s sends some previous point on the orbit to the current one
	    current_point = current_point^inv(s) # shift current one to the previous one
		# accumulate the change
		coset_rep = s * coset_rep
		# observe: coset_rep sends current_point to y.
	end
	coset_rep
end
```
>**Exercise 4**: Implement this function as in the cell below. Are all arguments actually needed?
"

# ╔═╡ a2db5382-9673-45d6-a485-5793baca8255
"""
	representative(y, S, Δ, Sch[, action=^])
Compute a representative `g` of left-coset `Stab_G(x)g` corresponding to point `y ∈ Δ` in the orbit of `x`.

## Input
* `y` - a point in `Δ`,
* `S` - a set of generators for `G = ⟨S⟩`,
* `Δ` - the orbit of `x` under the action of `G`,
* `Sch` - a Schreier tree for `Δ` and `S`.
## Output
* `g ∈ G` such that `xᵍ = y`.
"""
function representative(y, S::AbstractVector{<:GroupElement}, Δ, Sch, action=^)
    
    return g
end

# ╔═╡ ac3bf828-217c-4b4c-aa73-2217abf84111
let σ = Permutation([2,1,4,3]), τ = Permutation([1,3,4,2]), x = 2
	S = [σ, τ]
	@info "" S
	Δ, Sch = schreier(x, S)
	@assert length(Δ) == 4
	for δ in Δ
		@assert x^representative(δ, S, Δ, Sch) == δ
	end
end

# ╔═╡ 2e5c13c4-bfe6-4b89-89be-140520cd7dd4
md"
> **Exercise 5**: Design structs and interfaces for _orbits_, _transversals_ and _Schreier Vectors_.
> What are the common operations (=methods) we used so far?
> Can you think of a \"unifying\" architecture for all three of these objects?
"

# ╔═╡ ae92e313-c3a4-4fcf-a3f9-4c4b49102548
md"
In `schreier` we store indices (in `S`) of generators in the dictionary, so we need to keep the set around. It is not necessary though: since julia passes arguments by reference and `Permutation`s are heap-allocated there can be more than one reference to each `Permutation` at a given time. We can exploit it this feature to store directly references to generators in the dictionary. How? Just say `Sch[γ] = s` instead of `Sch[γ] = idx`.

> **Exercise 6**: modify implementation of `schreier` so that generators are stored directly. Modify `representative` accordingly.

To verify that the identical elements (and not marely equal) are present in `Sch` you may use `===` instead of `==`. While

	x = [1,2,3]; y = copy(x); x == y

returns `true`, `x===y` will be false since `x` and `y` occupy different space in memory (and modifications to `x` will not influence `y`).
"

# ╔═╡ 38485741-8200-4a45-be38-ac8f55501859
function schreier2(x, S::AbstractVector{<:GroupElement}, action=^)
    @assert !isempty(S)

    return Δ, Sch
end

# ╔═╡ e17132c0-1a59-412c-be50-6c6f6b99d09d
let σ = Permutation([2,1,4,3]), τ = Permutation([1,3,4,2]), x = 2
	S = [σ, τ]
	@info "" S
	Δ, Sch = schreier2(x, S)
	for (idx,δ) in pairs(Δ)
		δ == x && continue
		k = δ^inv(Sch[δ])
		@assert S[findfirst(==(Sch[δ]), S)] === Sch[δ] # note the === !
		@assert findfirst(==(k), Δ) < idx
	end
	S, Δ, Sch
end

# ╔═╡ 00000000-0000-0000-0000-000000000001
PLUTO_PROJECT_TOML_CONTENTS = """
[deps]
"""

# ╔═╡ 00000000-0000-0000-0000-000000000002
PLUTO_MANIFEST_TOML_CONTENTS = """
# This file is machine-generated - editing it directly is not advised

julia_version = "1.8.2"
manifest_format = "2.0"
project_hash = "da39a3ee5e6b4b0d3255bfef95601890afd80709"

[deps]
"""

# ╔═╡ Cell order:
# ╠═f36e0390-c44a-4901-83b5-d8180fcdaba6
# ╠═13abc38b-a0a2-46ac-a58a-24fead1f6702
# ╠═423e67fc-a756-4ba7-8e4d-fabfb7e22045
# ╠═57982949-1cb9-4077-afd7-444fb42f0fec
# ╠═cadb4c9c-2548-49ef-bf5b-4e018f886d9a
# ╠═261f2777-c2cc-498e-a7ef-a819f779344c
# ╠═9b3ef828-f64c-42b5-a7d8-ed7d2e0f96a9
# ╠═18121dc3-78d2-4334-b1bb-9b3cba02d730
# ╟─4118ac8d-3e55-4717-ac1f-98a3446b5eff
# ╠═f803b4d4-f93f-432f-950f-8699602f4d92
# ╟─e5f0e567-5d28-424e-83d0-4ca82e967865
# ╠═6007ee88-debe-4dc6-8bec-d730c38e0aec
# ╟─acf34ce7-45af-4de0-81c0-fa50948584ee
# ╠═9838d4b1-da7a-4b6a-8e18-a32ac465805c
# ╟─19367a34-9d88-4dbb-baed-4cea5b0a5eac
# ╠═f52cb4dd-03d8-4526-880c-4aaad81412ab
# ╠═2fa081db-4ae0-4af6-b513-65d32c3ff856
# ╟─8acfbaf5-498a-473c-b03a-5eab478ac3b3
# ╟─d20d14a4-3414-453d-943f-c760465d0ba7
# ╠═23122d5c-8545-43b9-a33a-2da78a46538a
# ╠═cc0fa689-6d78-4489-9faf-c4ef1b5dc762
# ╠═c73c88f0-a7ec-4260-af2a-665d1fadc150
# ╠═8951b592-0554-45c5-81b8-f1eac7d372dd
# ╠═b6669b69-53f2-4ef5-a17d-b45a9403a523
# ╟─c4c22682-4bbb-4d6d-a9a5-11afe67f200d
# ╠═a2db5382-9673-45d6-a485-5793baca8255
# ╠═ac3bf828-217c-4b4c-aa73-2217abf84111
# ╟─2e5c13c4-bfe6-4b89-89be-140520cd7dd4
# ╟─ae92e313-c3a4-4fcf-a3f9-4c4b49102548
# ╠═38485741-8200-4a45-be38-ac8f55501859
# ╠═e17132c0-1a59-412c-be50-6c6f6b99d09d
# ╟─00000000-0000-0000-0000-000000000001
# ╟─00000000-0000-0000-0000-000000000002
